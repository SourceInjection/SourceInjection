using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Text;
using TypeInfo = SourceInjection.SourceGeneration.Common.TypeInfo;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using SourceInjection.SourceGeneration.Diagnostics;
using SourceInjection.SourceGeneration.Common;
using SourceInjection.CodeAnalysis;

namespace SourceInjection.SourceGeneration.Base
{
    internal abstract class TypeSourceGeneratorBase : IIncrementalGenerator
    {
        protected internal abstract string Name { get; }

        protected abstract bool IsTargeted(INamedTypeSymbol symbol);

        protected abstract string TypeBody(TypeInfo typeInfo);

        protected virtual IEnumerable<string> Dependencies(TypeInfo typeInfo)
        {
            return Enumerable.Empty<string>();
        }

        protected virtual IEnumerable<string> InterfacesToAdd(TypeInfo typeInfo)
        {
            return Enumerable.Empty<string>();
        }

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var collected = context.SyntaxProvider.CreateSyntaxProvider(
                (n, _) => n is TypeDeclarationSyntax, 
                (n, _) => new { Context = n, Symbol = (INamedTypeSymbol)n.SemanticModel.GetDeclaredSymbol(n.Node) })
                .Collect();

            if (!TypeCollector.IsRegistered)
            {
                TypeCollector.IsRegistered = true;

                context.RegisterSourceOutput(collected, (_, types) =>
                {
                    foreach (var type in types)
                    {
                        var typeInfo = new TypeInfo(type.Context, (TypeDeclarationSyntax)type.Context.Node, type.Symbol);
                        TypeCollector.Consider(type.Symbol.ToDisplayString(), typeInfo);
                    }
                });
            }

            context.RegisterSourceOutput(collected, (sourceProductionContext, types) =>
            {
                foreach(var type in types.Where(t => IsTargeted(t.Symbol)))
                {
                    if (type.Context.Node.Parent is TypeDeclarationSyntax)
                        sourceProductionContext.ReportDiagnostic(Errors.NestedClassesAreNotSupported(type.Symbol, Name));
                    else
                    {
                        var typeInfo = new TypeInfo(type.Context, (TypeDeclarationSyntax)type.Context.Node, type.Symbol);

                        if (!typeInfo.HasPartialModifier)
                            sourceProductionContext.ReportDiagnostic(Errors.MissingPartialModifier(typeInfo.Symbol, Name));
                        else
                        {
                            var src = GeneratePartialType(typeInfo);
                            sourceProductionContext.AddSource(
                                $"{typeInfo.FullName.Replace('<', '[').Replace('>', ']').Replace('.', '/')}-{Name}.g.cs",
                                SourceText.From(src, Encoding.UTF8));
                        }
                    }
                }
            });
        }

        protected static EqualityComparerAttribute GetComparerAttribute(ISymbol symbol)
        {
            var attribute = symbol.AttributesOfType<EqualityComparerAttribute>()
                .FirstOrDefault();

            if (attribute != null && AttributeFactory.TryCreate<EqualityComparerAttribute>(attribute, out var config))
                return config;
            return null;
        }

        private string GeneratePartialType(TypeInfo typeInfo)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");

            foreach (var dependency in Dependencies(typeInfo))
                sb.AppendLine(dependency);

            sb.AppendLine();

            sb.AppendLine($"namespace {typeInfo.Symbol.ContainingNamespace.ToDisplayString()}");
            sb.AppendLine("{");
            sb.Append(Text.Indent());

            sb.Append(typeInfo.Declaration);
            var ifaces = InterfacesToAdd(typeInfo);
            if (!ifaces.Any())
                sb.AppendLine();
            else
                sb.AppendLine($" : {string.Join(", ", ifaces)}");
            sb.AppendLine(Text.Indent("{"));

            sb.AppendLine(TypeBody(typeInfo)
                .Replace("\n", $"\n{Text.Indent(tabCount: 2)}")
                .Insert(0, Text.Indent(tabCount: 2)));

            sb.AppendLine(Text.Indent("}"));
            sb.Append("}");

            return sb.ToString();
        }
    }
}
